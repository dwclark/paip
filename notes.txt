It looks like Part II covers mostly pattern matching and search. I will need to go back and review this and take a crack at implementing and perhaps correcting some "improvements" I made in implementing both GPS and Eliza. I simplified to solve the problem, but I didn't realize we were pushing towards more abstract versions of search and pattern matching. Maybe I can do better after learning more.

However, I am getting the feeling that pattern matching is a dead-end technique. It seems like chapters 7 and 8 have warnings about the shortcomings of pattern matching systems. But, it may still be good to understand this stuff. For one, there may be some problems where these simple ideas may prove beneficial. Secondly, by working through the problems, I will have a better understanding of why the techniques were abandoned.

Part III may be easier for me to get through as it looks like it's more programming focused and therefore may be more familiar to me.

Notes Chapter 9:

Yep, I was able to skim through it pretty fast.	The topics covered are summarized on page 269: caching, compiling, delaying, indexing.
Caching: mostly using memoization
Compiling: Converting runtime rule search into compile functions/lambdas
Delaying: Lazy evaluation
Indexing: Using data structures other than lists. BTW, my rule of thumb for Lisp is as follows: use lists for dealing with metaprogramming issues in Lisp, use vectors and hash tables for most other things.

Also some stuff on profiling, such as building your own profiling code. As SBCL comes with extensive profiling support, I mostly ignored that section.
